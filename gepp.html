<!DOCTYPE html>
<html>


<!-- Head section is for stuff that is not going to be on the page -->
<head>
	<meta charset="utf-8" />
	<title>Gunnar Portfolio</title>
	<link rel="stylesheet" href="styles/main.css">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0&icon_names=description,groups,link,list,manufacturing" />
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<!-- Favicon -->
	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
	<meta name="msapplication-TileColor" content="#00aba9">
	<meta name="theme-color" content="#ffffff">
</head>

<!-- Body is for everything on the page -->
<body>
	<!-- Sticky Header with socials-->
	<div class="sticky-header">
		<a class="sticky-header-button" href="mailto: gunnarmagnum@gmail.com">gunnarmagnum@gmail.com</a>
		<a class="sticky-header-button" href="https://github.com/Raestkjoot" target="_blank">
			<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-github" viewBox="0 0 16 16"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8"/></svg>
		</a>
		<a class="sticky-header-button" href="https://www.linkedin.com/in/gunnar-magnussen/" target="_blank">
			<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-linkedin" viewBox="0 0 16 16"><path d="M0 1.146C0 .513.526 0 1.175 0h13.65C15.474 0 16 .513 16 1.146v13.708c0 .633-.526 1.146-1.175 1.146H1.175C.526 16 0 15.487 0 14.854zm4.943 12.248V6.169H2.542v7.225zm-1.2-8.212c.837 0 1.358-.554 1.358-1.248-.015-.709-.52-1.248-1.342-1.248S2.4 3.226 2.4 3.934c0 .694.521 1.248 1.327 1.248zm4.908 8.212V9.359c0-.216.016-.432.08-.586.173-.431.568-.878 1.232-.878.869 0 1.216.662 1.216 1.634v3.865h2.401V9.25c0-2.22-1.184-3.252-2.764-3.252-1.274 0-1.845.7-2.165 1.193v.025h-.016l.016-.025V6.169h-2.4c.03.678 0 7.225 0 7.225z"/></svg>
		</a>
	</div>

	<!-- Header with navigation -->
	<header>
		<div>
			<h1>Gunnar Magnussen</h1>
			<p class="sub-title"><b>Game Programmer</b> | Gameplay, graphics and general game development.</p>
		</div>
		<div class="nav">
			<a class="header-button" href="index.html"> Projects </a>
			<a class="header-button" href="exp-and-edu.html"> Experience & Education </a>
			<a class="header-button" href="about-me.html"> About Me </a>
		</div>
	</header>

	<!-- TEXT -->
	 <div class="outer-text-container">
	<div class="text-container">
		<h1>GEPP</h1>
		<div class="project-overview">
			<div class="project-overview-elem">
				<iframe width="560" height="315" src="https://www.youtube.com/embed/91neiheLcFU?si=Ir_GgDadhfSNFzxT" title="YouTube video player" frameborder="0" 
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
					referrerpolicy="strict-origin-when-cross-origin" allowfullscreen>
				</iframe>
			</div>
			<div class="project-overview-elem">
				<i>
					<span class="material-symbols-outlined">manufacturing</span>
					&nbsp;<b>Engine:</b>&nbsp; Custom Engine
				</i>
				<i>
					<span class="material-symbols-outlined">description</span>
					&nbsp;<b>Language:</b>&nbsp; C++ | OpenGL
				</i>
				<i>
					<span class="material-symbols-outlined">list</span>
					&nbsp;<b>Tasks:</b>&nbsp; Movement | Physics | ECS | 2D batch rendering
				</i>
				<i>
					<span class="material-symbols-outlined">groups</span>
					&nbsp;<b>Team Size:</b>&nbsp; 1
				</i>
				<i>
					<span class="material-symbols-outlined">link</span>
					&nbsp;<b>Links:</b>&nbsp; <a class="links-button" href="https://github.com/Raestkjoot/AEGP" target="_blank">Source</a>
				</i>
				<i>
					I made a C++ game engine with 2D batch rendering and made a simple platformer prototype in that engine. 
					With this project I wanted to learn about engine and gameplay programming and really get past seeing the engine as a black box, and instead make one myself and learn exactly how they work.
				</i>
			</div>
		</div>
		<hr />

		<!-- GAMEPLAY -->
		<h2>
			Gameplay
		</h2>
		<p>
			Gameplay programming is probably my favorite type of game programming, because of how important it is in defining the player experience, 
			it sits in an interesting intersection between tech and design. 
			As part of my research for this project I looked into game feel and found a very interesting paper that broke it up into 3 distinct elements:
			<li>
				<b>Support:</b> Support the player's intention.
			</li>
			<li>
				<b>Amplification:</b> Audio and visual feedback
			</li>
			<li>
				<b>Physicality:</b> Feeling of how an object behaves
			</li>
		</p>
		<p>
			I found that focusing on these three elements provided a very clear language for thinking and communicating about game feel.
		</p>

<h3>
			Gameplay - Support
		</h3>
		<p>
			The idea with support is to make the game respond inline with player's feelings and intentions, rather than the purely logical state of the game.
			To support the player's intention, the platformer prototype has three different time values:
    </p>
		<li>
			<b>Coyote time:</b> This is a classic trick in platformer games, where the game has a small window after the character has run off an edge where the player can still jump.
		</li>
		<li>
			<b>Jump buffer, holding:</b> This lets the player buffer a jump by pressing and holding down the jump button before landing.
		</li>
		<li>
			<b>Jump buffer, released:</b> Since holding down the jump button lets you jump higher, sometimes you want to quickly tap the jump button to execute a short jump. 
			Timing a quick tap with the exact moment the character lands can be difficult, 
			so this buffer will buffer a jump for a small time frame if the player presses and releases the jump button just before landing.
		</li>
		<p>
			The left gif shows coyote time, the one on the right shows the jump buffer.
		</p>
		<div class="project-image-container">
			<img src="images/gepp-cayote-time.gif" class="project-image"/>
			<img src="images/gepp-jump-buffer.gif" class="project-image"/>
		</div>
		<p></p>
		<div class="code"><pre style="margin: 0; line-height: 125%; tab-size: 4;">
<span style="color: #ae81ff">bool</span> <span style="color: #66d9ef">MoveSystem</span>::<span style="color: #66d9ef">ShouldJump</span>(<span style="color: #ae81ff">const</span> <span style="color: #66d9ef">PlayerController</span>& pc) <span style="color: #ae81ff">const</span> {
	<span style="color: #ae81ff">bool</span> keyPressedInTime = pc.jumpReleased ?
		pc.passedTime - pc.jumpPressedTime < pc.jumpCache1 :
		pc.passedTime - pc.jumpPressedTime < pc.jumpCache2;

	<span style="color: #ae81ff">bool</span> coyote = pc.passedTime - pc.lastGroundedTime < pc.coyoteTime;

	<span style="color: #ae81ff">return</span> (pc.isGrounded || coyote) && keyPressedInTime && pc.readyToJumpAgain;
}</pre>
	</div>
	<p>
		Platformers often have ways to affect how far the player character jumps, the classic example is holding down the jump button to jump higher, which I implemented. 
		I also implemented a system that lets the player trade horizontal movement for vertical movement, introducting an interesting choise and use of momentum. 
		So, while in a jump moving upwards, the player can move against the initial horizontal direction to effectively convert their horizontal velocity into vertical velocity.
	</p>
	<div class="code"><pre style="margin: 0; line-height: 125%; tab-size: 4;">
<span style="color: #ae81ff">if</span> (playerController.jumpReleased || playerController.velocity.y < <span style="color: #ffbe21">-0.2f</span>) {
	playerController.velocity.y -= playerController.gravity * delta;
}
<span style="color: #ae81ff">else</span> {
	playerController.velocity.y -= playerController.jumpHeldGravity * delta;
}

<span style="color: #75715e">// Convert horizontal velocity to vertical velocity when going up</span>
<span style="color: #ae81ff">if</span> (playerController.velocity.y > <span style="color: #ffbe21">0.0f</span> 
	&& playerController.moveDirection * playerController.initialAirHorizontalVelocity < <span style="color: #ffbe21">0.0f</span> 
	&& playerController.moveDirection * playerController.velocity.x < <span style="color: #ffbe21">0.0f</span>) {
	playerController.velocity.y += playerController.airVerticalAcceleration * delta;
}</pre>
	</div>

		<h3>
			Gameplay - Amplification
		</h3>
		<p>
			The feedback that works to communicate the game state to the player, in my case, audio and visuals, but it could also include other forms of feedback such as haptic feedback. 
		</p>
		<p>
			For the visuals, I wanted the character to clearly communicate its state to the player, with idle, running, jumping and falling animations. 
			I modelled, rigged and animated the player character in blender and then rendered the animations into 2D frame animations. 
			This is the same technique that Dead Cells and Hades use to get nice and smooth 2D graphics that are easy to tweak and produce on a limited budget.
		</p>
		<img src="images/gepp-blender.png" class="project-image"/>
		<p>
			For the audio I decided to work with an audio designer and asked him what kind of functionality he would need. 
		</p>
		<blockquote>
			Music and sound design by Daniel Jakob. <br>
			<a href="https://danieljakob.net/" target="_blank">
				<img src="images/danieljakob.gif"> danieljakob.net
			</a>
			</blockquote>
		<p>
			I used a minimalistic audio engine library miniaudio, and implemented an AudioArray class that we used to play footsteps. 
			The AudioArray holds an array of audio samples that can be picked from at random without playing the same one twice in a row, 
			and lets the user specify a pitch range, so the footsteps always sound a little different.
		</p>
		<p>
			The audio array uses an std::vector to hold each audio sample. When I implemented this I started to experience crashes and realized 
			it was important to make the audio samples have a move constructor, to avoid them getting destroyed when they were moved to a new array.
		</p>
		<div class="code"><pre style="margin: 0; line-height: 125%; tab-size: 4;">
<span style="color: #66d9ef">Audio</span>::<span style="color: #66d9ef">Audio</span>(<span style="color: #66d9ef">Audio</span>&& other) <span style="color: #ae81ff">noexcept</span> {
	_audio = other._audio;
	_volume = other._volume;
	_pitch = other._pitch;
	other._audio = <span style="color: #ae81ff">nullptr</span>;
}</pre>
		</div>
		
		<h3>
			Gameplay - Physicality
		</h3>
		<p>
			I wanted to get the right balance between floaty jumps 
			- that feel smooth and like the player can string moves together and make use of momentum to move faster and better - 
			and more precise and rigid control that lets the player control the character very intuitively without having to try and account for sliding around too much.
		</p>
		<img src="images/gepp-gameplay-physicality.gif" class="project-image"/>
		<p>
			It also really helped having full control of how physics was handled, so I can make the player character interact with the environment exactly how I want.
		</p>

	<hr/>

	<!-- ENGINE -->
	<h2>
		Engine
	</h2>
	<h3>
		Engine - Rendering
	</h3>
	<p>
		For rendering I made a 2D batch renderer using OpenGL. Because everything is rendered in a single batch, there are 3 single elements of this renderer:
	</p>
	<li>
		<b>A vertex buffer:</b> Holds all the vertices that make up each quad. 
	</li>
	<li>
		<b>A uniform buffer:</b> Holds all sprite data for each quad.
	</li>
	<li>
		<b>A texture atlas:</b> Contains all the textures each of the sprites use.
	</li>
	<img src="images/gepp-renderer.jpg" class="project-image"/>

	<p>
		To make the vertices as light as possible, the flyweight pattern is used so they don't have to hold duplicate data. So each vertex contains:
	</p>
	<li>
		<b>Position:</b> local within the quad. Position &isin;  {(0, 0),(1, 0),(0, 1),(1, 1)}.
	</li>
	<li>
		<b>QuadID:</b> Used to index into the uniform buffer object to get the sprite data.
	</li>

	<p>
		The uniform buffer contains:
	</p>
	<li>
		Texture base coordinate
	</li>
	<li>
		Texture width-height
	</li>
	<li>
		Sprite world transform
	</li>
	<p>
		Here is a screenshot of the uniform buffer viewed in RenderDoc:
	</p>
	<img src="images/gepp-renderdoc.jpg" class="project-image" style="height: 400px"/>

	<p>
		With that we can calculate everything we need in our basic 2D renderer. Here is how the vertex shader calculates the texture coordinates and position:
	</p>
	<div class="code"><pre style="margin: 0; line-height: 125%; tab-size: 4;">
<span style="color: #ae81ff">void</span> main() {
   TexCoords = (quad[QuadID].TexBaseCoords + Pos * quad[QuadID].TexWidthHeight) / TexSize;

   <span style="color: #ae81ff">vec2</span> offsetPosition = Pos + Offset;
   <span style="color: #ae81ff">vec3</span> position = CameraMatrix * quad[QuadID].Transform * <span style="color: #ae81ff">vec3</span>(offsetPosition, 1.0f);
   <span style="color: #66d9ef">gl_Position</span> = <span style="color: #ae81ff">vec4</span>(position.xy, 0.5f, 1.0f);
}</pre>
	</div>

	<p>
		When I tested the performance, it turned out that the largest bottleneck was in how transforms were handled. 
		I saved the position, rotation and scale of each object and then calculated the transform every frame, which became very expensive with large amounts of objects. 
		To quickly and significanlty improve the performance of the engine with many sprites, I could store the transforms and calculate positions, rotations and scales from that when needed, 
		or cache the transforms, which was my initial plan.
	</p>

	<h3>
		Engine - Physics
	</h3>
	<p>
		All physics bodies are defined by axis aligned bounding boxes (AABBs). 
		The algorithm for detecting whether two AABBs overlap used is the Seperating Axis Theorem (SAT), which checks if there is an overlap on each axis. 
		Since we only have a collision if all axes overlap, we can early-out as soon as we find an axis where they do not overlap. 
	</p>
	<p>
		To resolve collisions, I used the projection-based method, where the object is moved back directly by changing its position. 
		The detection steps measures 4 overlap values in each direction, in this step I use those overlap measurements to find the direction with the smallest 
		amount of overlap and move the dynamic object back in that direction by the overlap amount so that the objects no longer overlap.
	</p>
	<div class="code"><pre style="margin: 0; line-height: 125%; tab-size: 4;">
<span style="color: #ae81ff">for</span> (<span style="color: #ae81ff">auto</span> [dEntity, dTrans, dAabb] : dynamicAABBs.<span style="color: #66d9ef">each</span>()) {
	<span style="color: #ae81ff">for</span> (<span style="color: #ae81ff">auto</span> [sEntity, sTrans, sAabb] : staticAABBs.<span style="color: #66d9ef">each</span>()) {
		<span style="color: #75715e">// COLLISION DETECTION
		// Measure overlaps and early return if there is an edge with no overlap</span>
		<span style="color: #ae81ff">if</span> ((overlaps[<span style="color: #ffbe21">0</span>] = dTrans.position.x + dAabb.extents.x - (sTrans.position.x - sAabb.extents.x)) < <span style="color: #ffbe21">0.0f</span>) { <span style="color: #ae81ff">continue</span>; }
		<span style="color: #ae81ff">if</span> ((overlaps[<span style="color: #ffbe21">1</span>] = sTrans.position.x + sAabb.extents.x - (dTrans.position.x - dAabb.extents.x)) < <span style="color: #ffbe21">0.0f</span>) { <span style="color: #ae81ff">continue</span>; }
		<span style="color: #ae81ff">if</span> ((overlaps[<span style="color: #ffbe21">2</span>] = dTrans.position.y + dAabb.extents.y - (sTrans.position.y - sAabb.extents.y)) < <span style="color: #ffbe21">0.0f</span>) { <span style="color: #ae81ff">continue</span>; }
		<span style="color: #ae81ff">if</span> ((overlaps[<span style="color: #ffbe21">3</span>] = sTrans.position.y + sAabb.extents.y - (dTrans.position.y - dAabb.extents.y)) < <span style="color: #ffbe21">0.0f</span>) { <span style="color: #ae81ff">continue</span>; }

		<span style="color: #75715e">// COLLISION RESPONSE
		// If we get to this point, all edges have overlap and we know the AABBs overlap.
		// Find edge with smallest overlap and move the dynamic object back on that edge so there is no more overlap.</span>
		minDist = std::<span style="color: #ae81ff">numeric_limits</span><<span style="color: #ae81ff">float</span>>::<span style="color: #ae81ff">max</span>();

		<span style="color: #ae81ff">for</span> (<span style="color: #ae81ff">int</span> i = <span style="color: #ffbe21">0</span>; i < <span style="color: #ffbe21">4</span>; ++i) {
			<span style="color: #ae81ff">if</span> (minDist > overlaps[i]) {
				minDist = overlaps[i];
				projVecIndex = i;
			}
		}

		<span style="color: #ae81ff">switch</span> (projVecIndex)
		{
		<span style="color: #ae81ff">case</span> <span style="color: #ffbe21">0</span>:
			dTrans.position.x -= minDist;
			break;
		<span style="color: #ae81ff">case</span> <span style="color: #ffbe21">1</span>:
			dTrans.position.x += minDist;
			break;
		<span style="color: #ae81ff">case</span> <span style="color: #ffbe21">2</span>:
			dTrans.position.y -= minDist;
			break;
		<span style="color: #ae81ff">case</span> <span style="color: #ffbe21">3</span>:
			dTrans.position.y += minDist;
		}
	}
}</pre>
	</div>
	<p>
		The simplicity of this algorithm is so effective, that even with 1000s of of AABBs and brute force collision detection, collision detection barely had an effect on performance. 
		This is also in large part because the only dynamic object in my test game is the player character, and the system only performs dynamic vs static collision detection. 
	</p>

	<h3>
		Engine - Entity Component System
	</h3>
	<p>
		The architectural pattern I used to structure the game code is the Entity Component System. 
		This is a data-oriented way to structure code, which can potentially improve performance significantly. 
		For this I used a third-party library, EnTT, which is also used in Minecraft Bedrock Edition.
	</p>
	<p>
		Unity DOTS uses archetype ECS, where each unique *set* of components belong to a specific archetype array. 
		This method provides a fast look-up and general optimization on how the components are stored. 
		Though it does add some extra cost to removing and adding components, as this changes the archetype it belongs to.
	</p>
	<p>
		EnTT uses sparse set ECS, where each component *type* belongs to a specific component array. 
		To find all sets of some specific components, we have to iterate all the components in one of the component arrays and check against the other arrays,
		 which is much less optimal that archetype ECS. However, with sparse set ECS we have the ability to optimize for specific groups based on where we find bottlenecks. 
		 We can do this by sorting components that belong to those groups so that they are always together at the front of the array. 
		 So EnTT lets us optimize access to the most performance-critical sets of components.
	</p>
	<p>
		Using ECS turned out to work really well with naturally making big engine-related systems such as sprite rendering and physics, and made it very easy to reason about the order of different systems. 
	</p>


	</div>
</div>

</body>
</html>